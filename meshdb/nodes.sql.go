// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: nodes.sql

package meshdb

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countNodesByMesh = `-- name: CountNodesByMesh :one
SELECT COUNT(*) FROM nodes
WHERE mesh_id = $1
`

func (q *Queries) CountNodesByMesh(ctx context.Context, meshID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countNodesByMesh, meshID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNode = `-- name: CreateNode :one
INSERT INTO nodes (mesh_id, hardware_id, name, long_name, role, public_key, private_key, status, unmessageable)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at
`

type CreateNodeParams struct {
	MeshID        int64   `json:"mesh_id"`
	HardwareID    string  `json:"hardware_id"`
	Name          string  `json:"name"`
	LongName      string  `json:"long_name"`
	Role          *string `json:"role"`
	PublicKey     *string `json:"public_key"`
	PrivateKey    *string `json:"private_key"`
	Status        *string `json:"status"`
	Unmessageable bool    `json:"unmessageable"`
}

func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (Node, error) {
	row := q.db.QueryRow(ctx, createNode,
		arg.MeshID,
		arg.HardwareID,
		arg.Name,
		arg.LongName,
		arg.Role,
		arg.PublicKey,
		arg.PrivateKey,
		arg.Status,
		arg.Unmessageable,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.HardwareID,
		&i.Name,
		&i.LongName,
		&i.Role,
		&i.PublicKey,
		&i.PrivateKey,
		&i.LastSeen,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AppliedName,
		&i.AppliedLongName,
		&i.AppliedRole,
		&i.AppliedPublicKey,
		&i.AppliedPrivateKey,
		&i.AppliedUnmessageable,
		&i.Unmessageable,
		&i.ConfigAppliedAt,
		&i.PendingChanges,
		&i.NodeNum,
		&i.DeviceID,
		&i.FirmwareVersion,
		&i.HwModel,
		&i.ShortName,
		&i.RawDeviceConfig,
		&i.ConfigOverrides,
		&i.ConfigImportedAt,
	)
	return i, err
}

const deleteNode = `-- name: DeleteNode :exec
DELETE FROM nodes
WHERE id = $1
`

func (q *Queries) DeleteNode(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteNode, id)
	return err
}

const getNode = `-- name: GetNode :one
SELECT id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at FROM nodes
WHERE id = $1
`

func (q *Queries) GetNode(ctx context.Context, id int64) (Node, error) {
	row := q.db.QueryRow(ctx, getNode, id)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.HardwareID,
		&i.Name,
		&i.LongName,
		&i.Role,
		&i.PublicKey,
		&i.PrivateKey,
		&i.LastSeen,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AppliedName,
		&i.AppliedLongName,
		&i.AppliedRole,
		&i.AppliedPublicKey,
		&i.AppliedPrivateKey,
		&i.AppliedUnmessageable,
		&i.Unmessageable,
		&i.ConfigAppliedAt,
		&i.PendingChanges,
		&i.NodeNum,
		&i.DeviceID,
		&i.FirmwareVersion,
		&i.HwModel,
		&i.ShortName,
		&i.RawDeviceConfig,
		&i.ConfigOverrides,
		&i.ConfigImportedAt,
	)
	return i, err
}

const getNodeByHardwareID = `-- name: GetNodeByHardwareID :one
SELECT id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at FROM nodes
WHERE mesh_id = $1 AND hardware_id = $2
`

type GetNodeByHardwareIDParams struct {
	MeshID     int64  `json:"mesh_id"`
	HardwareID string `json:"hardware_id"`
}

func (q *Queries) GetNodeByHardwareID(ctx context.Context, arg GetNodeByHardwareIDParams) (Node, error) {
	row := q.db.QueryRow(ctx, getNodeByHardwareID, arg.MeshID, arg.HardwareID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.HardwareID,
		&i.Name,
		&i.LongName,
		&i.Role,
		&i.PublicKey,
		&i.PrivateKey,
		&i.LastSeen,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AppliedName,
		&i.AppliedLongName,
		&i.AppliedRole,
		&i.AppliedPublicKey,
		&i.AppliedPrivateKey,
		&i.AppliedUnmessageable,
		&i.Unmessageable,
		&i.ConfigAppliedAt,
		&i.PendingChanges,
		&i.NodeNum,
		&i.DeviceID,
		&i.FirmwareVersion,
		&i.HwModel,
		&i.ShortName,
		&i.RawDeviceConfig,
		&i.ConfigOverrides,
		&i.ConfigImportedAt,
	)
	return i, err
}

const getNodeEffectiveConfig = `-- name: GetNodeEffectiveConfig :one
SELECT
    n.id,
    n.hardware_id,
    n.node_num,
    n.device_id,
    n.name,
    n.long_name,
    n.short_name,
    m.config_defaults || n.config_overrides as effective_config,
    n.raw_device_config,
    n.config_imported_at,
    n.config_applied_at,
    n.pending_changes
FROM nodes n
JOIN meshes m ON n.mesh_id = m.id
WHERE n.id = $1
`

type GetNodeEffectiveConfigRow struct {
	ID               int64       `json:"id"`
	HardwareID       string      `json:"hardware_id"`
	NodeNum          *int64      `json:"node_num"`
	DeviceID         []byte      `json:"device_id"`
	Name             string      `json:"name"`
	LongName         string      `json:"long_name"`
	ShortName        *string     `json:"short_name"`
	EffectiveConfig  interface{} `json:"effective_config"`
	RawDeviceConfig  []byte      `json:"raw_device_config"`
	ConfigImportedAt *time.Time  `json:"config_imported_at"`
	ConfigAppliedAt  *time.Time  `json:"config_applied_at"`
	PendingChanges   bool        `json:"pending_changes"`
}

// Get the effective config for a node (merging mesh defaults with node overrides)
// This is a JSON merge operation
func (q *Queries) GetNodeEffectiveConfig(ctx context.Context, id int64) (GetNodeEffectiveConfigRow, error) {
	row := q.db.QueryRow(ctx, getNodeEffectiveConfig, id)
	var i GetNodeEffectiveConfigRow
	err := row.Scan(
		&i.ID,
		&i.HardwareID,
		&i.NodeNum,
		&i.DeviceID,
		&i.Name,
		&i.LongName,
		&i.ShortName,
		&i.EffectiveConfig,
		&i.RawDeviceConfig,
		&i.ConfigImportedAt,
		&i.ConfigAppliedAt,
		&i.PendingChanges,
	)
	return i, err
}

const importNodeConfig = `-- name: ImportNodeConfig :one
INSERT INTO nodes (
    mesh_id,
    hardware_id,
    node_num,
    device_id,
    name,
    long_name,
    short_name,
    firmware_version,
    hw_model,
    public_key,
    private_key,
    raw_device_config,
    config_imported_at,
    last_seen,
    status
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    NOW(),
    NOW(),
    'online'
)
ON CONFLICT (mesh_id, hardware_id)
DO UPDATE SET
    node_num = EXCLUDED.node_num,
    device_id = EXCLUDED.device_id,
    long_name = EXCLUDED.long_name,
    short_name = EXCLUDED.short_name,
    firmware_version = EXCLUDED.firmware_version,
    hw_model = EXCLUDED.hw_model,
    public_key = EXCLUDED.public_key,
    private_key = EXCLUDED.private_key,
    raw_device_config = EXCLUDED.raw_device_config,
    config_imported_at = NOW(),
    last_seen = NOW(),
    status = 'online',
    updated_at = NOW()
RETURNING id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at
`

type ImportNodeConfigParams struct {
	MeshID          int64       `json:"mesh_id"`
	HardwareID      string      `json:"hardware_id"`
	NodeNum         *int64      `json:"node_num"`
	DeviceID        []byte      `json:"device_id"`
	Name            string      `json:"name"`
	LongName        string      `json:"long_name"`
	ShortName       *string     `json:"short_name"`
	FirmwareVersion *string     `json:"firmware_version"`
	HwModel         pgtype.Int4 `json:"hw_model"`
	PublicKey       *string     `json:"public_key"`
	PrivateKey      *string     `json:"private_key"`
	RawDeviceConfig []byte      `json:"raw_device_config"`
}

// Import or update node configuration from device scan
func (q *Queries) ImportNodeConfig(ctx context.Context, arg ImportNodeConfigParams) (Node, error) {
	row := q.db.QueryRow(ctx, importNodeConfig,
		arg.MeshID,
		arg.HardwareID,
		arg.NodeNum,
		arg.DeviceID,
		arg.Name,
		arg.LongName,
		arg.ShortName,
		arg.FirmwareVersion,
		arg.HwModel,
		arg.PublicKey,
		arg.PrivateKey,
		arg.RawDeviceConfig,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.HardwareID,
		&i.Name,
		&i.LongName,
		&i.Role,
		&i.PublicKey,
		&i.PrivateKey,
		&i.LastSeen,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AppliedName,
		&i.AppliedLongName,
		&i.AppliedRole,
		&i.AppliedPublicKey,
		&i.AppliedPrivateKey,
		&i.AppliedUnmessageable,
		&i.Unmessageable,
		&i.ConfigAppliedAt,
		&i.PendingChanges,
		&i.NodeNum,
		&i.DeviceID,
		&i.FirmwareVersion,
		&i.HwModel,
		&i.ShortName,
		&i.RawDeviceConfig,
		&i.ConfigOverrides,
		&i.ConfigImportedAt,
	)
	return i, err
}

const listNodesByMesh = `-- name: ListNodesByMesh :many
SELECT id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at FROM nodes
WHERE mesh_id = $1
ORDER BY name ASC
`

func (q *Queries) ListNodesByMesh(ctx context.Context, meshID int64) ([]Node, error) {
	rows, err := q.db.Query(ctx, listNodesByMesh, meshID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.MeshID,
			&i.HardwareID,
			&i.Name,
			&i.LongName,
			&i.Role,
			&i.PublicKey,
			&i.PrivateKey,
			&i.LastSeen,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AppliedName,
			&i.AppliedLongName,
			&i.AppliedRole,
			&i.AppliedPublicKey,
			&i.AppliedPrivateKey,
			&i.AppliedUnmessageable,
			&i.Unmessageable,
			&i.ConfigAppliedAt,
			&i.PendingChanges,
			&i.NodeNum,
			&i.DeviceID,
			&i.FirmwareVersion,
			&i.HwModel,
			&i.ShortName,
			&i.RawDeviceConfig,
			&i.ConfigOverrides,
			&i.ConfigImportedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodesWithPendingChanges = `-- name: ListNodesWithPendingChanges :many
SELECT id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at FROM nodes
WHERE mesh_id = $1 AND pending_changes = TRUE
ORDER BY name ASC
`

func (q *Queries) ListNodesWithPendingChanges(ctx context.Context, meshID int64) ([]Node, error) {
	rows, err := q.db.Query(ctx, listNodesWithPendingChanges, meshID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.MeshID,
			&i.HardwareID,
			&i.Name,
			&i.LongName,
			&i.Role,
			&i.PublicKey,
			&i.PrivateKey,
			&i.LastSeen,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AppliedName,
			&i.AppliedLongName,
			&i.AppliedRole,
			&i.AppliedPublicKey,
			&i.AppliedPrivateKey,
			&i.AppliedUnmessageable,
			&i.Unmessageable,
			&i.ConfigAppliedAt,
			&i.PendingChanges,
			&i.NodeNum,
			&i.DeviceID,
			&i.FirmwareVersion,
			&i.HwModel,
			&i.ShortName,
			&i.RawDeviceConfig,
			&i.ConfigOverrides,
			&i.ConfigImportedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNode = `-- name: UpdateNode :one
UPDATE nodes
SET
    name = COALESCE($1, name),
    long_name = COALESCE($2, long_name),
    role = COALESCE($3, role),
    public_key = COALESCE($4, public_key),
    private_key = COALESCE($5, private_key),
    status = COALESCE($6, status),
    unmessageable = COALESCE($7, unmessageable),
    last_seen = COALESCE($8, last_seen),
    pending_changes = COALESCE($9, pending_changes),
    updated_at = NOW()
WHERE id = $10
RETURNING id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at
`

type UpdateNodeParams struct {
	Name           *string     `json:"name"`
	LongName       *string     `json:"long_name"`
	Role           *string     `json:"role"`
	PublicKey      *string     `json:"public_key"`
	PrivateKey     *string     `json:"private_key"`
	Status         *string     `json:"status"`
	Unmessageable  pgtype.Bool `json:"unmessageable"`
	LastSeen       *time.Time  `json:"last_seen"`
	PendingChanges pgtype.Bool `json:"pending_changes"`
	ID             int64       `json:"id"`
}

func (q *Queries) UpdateNode(ctx context.Context, arg UpdateNodeParams) (Node, error) {
	row := q.db.QueryRow(ctx, updateNode,
		arg.Name,
		arg.LongName,
		arg.Role,
		arg.PublicKey,
		arg.PrivateKey,
		arg.Status,
		arg.Unmessageable,
		arg.LastSeen,
		arg.PendingChanges,
		arg.ID,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.HardwareID,
		&i.Name,
		&i.LongName,
		&i.Role,
		&i.PublicKey,
		&i.PrivateKey,
		&i.LastSeen,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AppliedName,
		&i.AppliedLongName,
		&i.AppliedRole,
		&i.AppliedPublicKey,
		&i.AppliedPrivateKey,
		&i.AppliedUnmessageable,
		&i.Unmessageable,
		&i.ConfigAppliedAt,
		&i.PendingChanges,
		&i.NodeNum,
		&i.DeviceID,
		&i.FirmwareVersion,
		&i.HwModel,
		&i.ShortName,
		&i.RawDeviceConfig,
		&i.ConfigOverrides,
		&i.ConfigImportedAt,
	)
	return i, err
}

const updateNodeAppliedState = `-- name: UpdateNodeAppliedState :one
UPDATE nodes
SET
    applied_name = $1,
    applied_long_name = $2,
    applied_role = $3,
    applied_public_key = $4,
    applied_private_key = $5,
    applied_unmessageable = $6,
    config_applied_at = NOW(),
    pending_changes = FALSE,
    updated_at = NOW()
WHERE id = $7
RETURNING id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at
`

type UpdateNodeAppliedStateParams struct {
	AppliedName          *string     `json:"applied_name"`
	AppliedLongName      *string     `json:"applied_long_name"`
	AppliedRole          *string     `json:"applied_role"`
	AppliedPublicKey     *string     `json:"applied_public_key"`
	AppliedPrivateKey    *string     `json:"applied_private_key"`
	AppliedUnmessageable pgtype.Bool `json:"applied_unmessageable"`
	ID                   int64       `json:"id"`
}

func (q *Queries) UpdateNodeAppliedState(ctx context.Context, arg UpdateNodeAppliedStateParams) (Node, error) {
	row := q.db.QueryRow(ctx, updateNodeAppliedState,
		arg.AppliedName,
		arg.AppliedLongName,
		arg.AppliedRole,
		arg.AppliedPublicKey,
		arg.AppliedPrivateKey,
		arg.AppliedUnmessageable,
		arg.ID,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.HardwareID,
		&i.Name,
		&i.LongName,
		&i.Role,
		&i.PublicKey,
		&i.PrivateKey,
		&i.LastSeen,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AppliedName,
		&i.AppliedLongName,
		&i.AppliedRole,
		&i.AppliedPublicKey,
		&i.AppliedPrivateKey,
		&i.AppliedUnmessageable,
		&i.Unmessageable,
		&i.ConfigAppliedAt,
		&i.PendingChanges,
		&i.NodeNum,
		&i.DeviceID,
		&i.FirmwareVersion,
		&i.HwModel,
		&i.ShortName,
		&i.RawDeviceConfig,
		&i.ConfigOverrides,
		&i.ConfigImportedAt,
	)
	return i, err
}

const updateNodeConfigOverrides = `-- name: UpdateNodeConfigOverrides :one
UPDATE nodes
SET
    config_overrides = $1,
    pending_changes = TRUE,
    updated_at = NOW()
WHERE id = $2
RETURNING id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at
`

type UpdateNodeConfigOverridesParams struct {
	ConfigOverrides []byte `json:"config_overrides"`
	ID              int64  `json:"id"`
}

// Update node-specific config overrides
func (q *Queries) UpdateNodeConfigOverrides(ctx context.Context, arg UpdateNodeConfigOverridesParams) (Node, error) {
	row := q.db.QueryRow(ctx, updateNodeConfigOverrides, arg.ConfigOverrides, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.HardwareID,
		&i.Name,
		&i.LongName,
		&i.Role,
		&i.PublicKey,
		&i.PrivateKey,
		&i.LastSeen,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AppliedName,
		&i.AppliedLongName,
		&i.AppliedRole,
		&i.AppliedPublicKey,
		&i.AppliedPrivateKey,
		&i.AppliedUnmessageable,
		&i.Unmessageable,
		&i.ConfigAppliedAt,
		&i.PendingChanges,
		&i.NodeNum,
		&i.DeviceID,
		&i.FirmwareVersion,
		&i.HwModel,
		&i.ShortName,
		&i.RawDeviceConfig,
		&i.ConfigOverrides,
		&i.ConfigImportedAt,
	)
	return i, err
}

const updateNodeStatus = `-- name: UpdateNodeStatus :one
UPDATE nodes
SET
    status = $1,
    last_seen = NOW(),
    updated_at = NOW()
WHERE id = $2
RETURNING id, mesh_id, hardware_id, name, long_name, role, public_key, private_key, last_seen, status, created_at, updated_at, applied_name, applied_long_name, applied_role, applied_public_key, applied_private_key, applied_unmessageable, unmessageable, config_applied_at, pending_changes, node_num, device_id, firmware_version, hw_model, short_name, raw_device_config, config_overrides, config_imported_at
`

type UpdateNodeStatusParams struct {
	Status *string `json:"status"`
	ID     int64   `json:"id"`
}

func (q *Queries) UpdateNodeStatus(ctx context.Context, arg UpdateNodeStatusParams) (Node, error) {
	row := q.db.QueryRow(ctx, updateNodeStatus, arg.Status, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.HardwareID,
		&i.Name,
		&i.LongName,
		&i.Role,
		&i.PublicKey,
		&i.PrivateKey,
		&i.LastSeen,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AppliedName,
		&i.AppliedLongName,
		&i.AppliedRole,
		&i.AppliedPublicKey,
		&i.AppliedPrivateKey,
		&i.AppliedUnmessageable,
		&i.Unmessageable,
		&i.ConfigAppliedAt,
		&i.PendingChanges,
		&i.NodeNum,
		&i.DeviceID,
		&i.FirmwareVersion,
		&i.HwModel,
		&i.ShortName,
		&i.RawDeviceConfig,
		&i.ConfigOverrides,
		&i.ConfigImportedAt,
	)
	return i, err
}
