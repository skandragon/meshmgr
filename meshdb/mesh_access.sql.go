// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: mesh_access.sql

package meshdb

import (
	"context"
	"time"
)

const checkUserMeshAccess = `-- name: CheckUserMeshAccess :one
SELECT access_level FROM mesh_access
WHERE mesh_id = $1 AND user_id = $2
`

type CheckUserMeshAccessParams struct {
	MeshID int64 `json:"mesh_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) CheckUserMeshAccess(ctx context.Context, arg CheckUserMeshAccessParams) (string, error) {
	row := q.db.QueryRow(ctx, checkUserMeshAccess, arg.MeshID, arg.UserID)
	var access_level string
	err := row.Scan(&access_level)
	return access_level, err
}

const getMeshAccess = `-- name: GetMeshAccess :one
SELECT id, mesh_id, user_id, access_level, granted_by, created_at FROM mesh_access
WHERE mesh_id = $1 AND user_id = $2
`

type GetMeshAccessParams struct {
	MeshID int64 `json:"mesh_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetMeshAccess(ctx context.Context, arg GetMeshAccessParams) (MeshAccess, error) {
	row := q.db.QueryRow(ctx, getMeshAccess, arg.MeshID, arg.UserID)
	var i MeshAccess
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.UserID,
		&i.AccessLevel,
		&i.GrantedBy,
		&i.CreatedAt,
	)
	return i, err
}

const grantMeshAccess = `-- name: GrantMeshAccess :one
INSERT INTO mesh_access (mesh_id, user_id, access_level, granted_by)
VALUES ($1, $2, $3, $4)
RETURNING id, mesh_id, user_id, access_level, granted_by, created_at
`

type GrantMeshAccessParams struct {
	MeshID      int64  `json:"mesh_id"`
	UserID      int64  `json:"user_id"`
	AccessLevel string `json:"access_level"`
	GrantedBy   *int64 `json:"granted_by"`
}

func (q *Queries) GrantMeshAccess(ctx context.Context, arg GrantMeshAccessParams) (MeshAccess, error) {
	row := q.db.QueryRow(ctx, grantMeshAccess,
		arg.MeshID,
		arg.UserID,
		arg.AccessLevel,
		arg.GrantedBy,
	)
	var i MeshAccess
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.UserID,
		&i.AccessLevel,
		&i.GrantedBy,
		&i.CreatedAt,
	)
	return i, err
}

const listMeshAccessByMesh = `-- name: ListMeshAccessByMesh :many
SELECT ma.id, ma.mesh_id, ma.user_id, ma.access_level, ma.granted_by, ma.created_at, u.email, u.display_name
FROM mesh_access ma
JOIN users u ON ma.user_id = u.id
WHERE ma.mesh_id = $1
ORDER BY ma.created_at DESC
`

type ListMeshAccessByMeshRow struct {
	ID          int64     `json:"id"`
	MeshID      int64     `json:"mesh_id"`
	UserID      int64     `json:"user_id"`
	AccessLevel string    `json:"access_level"`
	GrantedBy   *int64    `json:"granted_by"`
	CreatedAt   time.Time `json:"created_at"`
	Email       string    `json:"email"`
	DisplayName string    `json:"display_name"`
}

func (q *Queries) ListMeshAccessByMesh(ctx context.Context, meshID int64) ([]ListMeshAccessByMeshRow, error) {
	rows, err := q.db.Query(ctx, listMeshAccessByMesh, meshID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMeshAccessByMeshRow
	for rows.Next() {
		var i ListMeshAccessByMeshRow
		if err := rows.Scan(
			&i.ID,
			&i.MeshID,
			&i.UserID,
			&i.AccessLevel,
			&i.GrantedBy,
			&i.CreatedAt,
			&i.Email,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMeshAccessByUser = `-- name: ListMeshAccessByUser :many
SELECT ma.id, ma.mesh_id, ma.user_id, ma.access_level, ma.granted_by, ma.created_at, m.name as mesh_name
FROM mesh_access ma
JOIN meshes m ON ma.mesh_id = m.id
WHERE ma.user_id = $1
ORDER BY ma.created_at DESC
`

type ListMeshAccessByUserRow struct {
	ID          int64     `json:"id"`
	MeshID      int64     `json:"mesh_id"`
	UserID      int64     `json:"user_id"`
	AccessLevel string    `json:"access_level"`
	GrantedBy   *int64    `json:"granted_by"`
	CreatedAt   time.Time `json:"created_at"`
	MeshName    string    `json:"mesh_name"`
}

func (q *Queries) ListMeshAccessByUser(ctx context.Context, userID int64) ([]ListMeshAccessByUserRow, error) {
	rows, err := q.db.Query(ctx, listMeshAccessByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMeshAccessByUserRow
	for rows.Next() {
		var i ListMeshAccessByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.MeshID,
			&i.UserID,
			&i.AccessLevel,
			&i.GrantedBy,
			&i.CreatedAt,
			&i.MeshName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeMeshAccess = `-- name: RevokeMeshAccess :exec
DELETE FROM mesh_access
WHERE mesh_id = $1 AND user_id = $2
`

type RevokeMeshAccessParams struct {
	MeshID int64 `json:"mesh_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) RevokeMeshAccess(ctx context.Context, arg RevokeMeshAccessParams) error {
	_, err := q.db.Exec(ctx, revokeMeshAccess, arg.MeshID, arg.UserID)
	return err
}

const updateMeshAccess = `-- name: UpdateMeshAccess :one
UPDATE mesh_access
SET
    access_level = $1
WHERE mesh_id = $2 AND user_id = $3
RETURNING id, mesh_id, user_id, access_level, granted_by, created_at
`

type UpdateMeshAccessParams struct {
	AccessLevel string `json:"access_level"`
	MeshID      int64  `json:"mesh_id"`
	UserID      int64  `json:"user_id"`
}

func (q *Queries) UpdateMeshAccess(ctx context.Context, arg UpdateMeshAccessParams) (MeshAccess, error) {
	row := q.db.QueryRow(ctx, updateMeshAccess, arg.AccessLevel, arg.MeshID, arg.UserID)
	var i MeshAccess
	err := row.Scan(
		&i.ID,
		&i.MeshID,
		&i.UserID,
		&i.AccessLevel,
		&i.GrantedBy,
		&i.CreatedAt,
	)
	return i, err
}
