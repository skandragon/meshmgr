// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: node_admin_keys.sql

package meshdb

import (
	"context"
	"time"
)

const assignAdminKeyToNode = `-- name: AssignAdminKeyToNode :one
INSERT INTO node_admin_keys (node_id, admin_key_id)
VALUES ($1, $2)
ON CONFLICT (node_id, admin_key_id) DO UPDATE
SET applied_at = NOW(), is_current = TRUE
RETURNING id, node_id, admin_key_id, applied_at, is_current
`

type AssignAdminKeyToNodeParams struct {
	NodeID     int64 `json:"node_id"`
	AdminKeyID int64 `json:"admin_key_id"`
}

func (q *Queries) AssignAdminKeyToNode(ctx context.Context, arg AssignAdminKeyToNodeParams) (NodeAdminKey, error) {
	row := q.db.QueryRow(ctx, assignAdminKeyToNode, arg.NodeID, arg.AdminKeyID)
	var i NodeAdminKey
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.AdminKeyID,
		&i.AppliedAt,
		&i.IsCurrent,
	)
	return i, err
}

const deleteNodeAdminKeyMapping = `-- name: DeleteNodeAdminKeyMapping :exec
DELETE FROM node_admin_keys
WHERE node_id = $1 AND admin_key_id = $2
`

type DeleteNodeAdminKeyMappingParams struct {
	NodeID     int64 `json:"node_id"`
	AdminKeyID int64 `json:"admin_key_id"`
}

func (q *Queries) DeleteNodeAdminKeyMapping(ctx context.Context, arg DeleteNodeAdminKeyMappingParams) error {
	_, err := q.db.Exec(ctx, deleteNodeAdminKeyMapping, arg.NodeID, arg.AdminKeyID)
	return err
}

const getCurrentAdminKeysForNode = `-- name: GetCurrentAdminKeysForNode :many
SELECT nak.id, nak.node_id, nak.admin_key_id, nak.applied_at, nak.is_current, ak.key_name, ak.public_key
FROM node_admin_keys nak
JOIN admin_keys ak ON nak.admin_key_id = ak.id
WHERE nak.node_id = $1 AND nak.is_current = TRUE
ORDER BY nak.applied_at DESC
`

type GetCurrentAdminKeysForNodeRow struct {
	ID         int64     `json:"id"`
	NodeID     int64     `json:"node_id"`
	AdminKeyID int64     `json:"admin_key_id"`
	AppliedAt  time.Time `json:"applied_at"`
	IsCurrent  bool      `json:"is_current"`
	KeyName    *string   `json:"key_name"`
	PublicKey  string    `json:"public_key"`
}

func (q *Queries) GetCurrentAdminKeysForNode(ctx context.Context, nodeID int64) ([]GetCurrentAdminKeysForNodeRow, error) {
	rows, err := q.db.Query(ctx, getCurrentAdminKeysForNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentAdminKeysForNodeRow
	for rows.Next() {
		var i GetCurrentAdminKeysForNodeRow
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.AdminKeyID,
			&i.AppliedAt,
			&i.IsCurrent,
			&i.KeyName,
			&i.PublicKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminKeysForNode = `-- name: ListAdminKeysForNode :many
SELECT nak.id, nak.node_id, nak.admin_key_id, nak.applied_at, nak.is_current, ak.key_name, ak.public_key
FROM node_admin_keys nak
JOIN admin_keys ak ON nak.admin_key_id = ak.id
WHERE nak.node_id = $1
ORDER BY nak.applied_at DESC
`

type ListAdminKeysForNodeRow struct {
	ID         int64     `json:"id"`
	NodeID     int64     `json:"node_id"`
	AdminKeyID int64     `json:"admin_key_id"`
	AppliedAt  time.Time `json:"applied_at"`
	IsCurrent  bool      `json:"is_current"`
	KeyName    *string   `json:"key_name"`
	PublicKey  string    `json:"public_key"`
}

func (q *Queries) ListAdminKeysForNode(ctx context.Context, nodeID int64) ([]ListAdminKeysForNodeRow, error) {
	rows, err := q.db.Query(ctx, listAdminKeysForNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAdminKeysForNodeRow
	for rows.Next() {
		var i ListAdminKeysForNodeRow
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.AdminKeyID,
			&i.AppliedAt,
			&i.IsCurrent,
			&i.KeyName,
			&i.PublicKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodesForAdminKey = `-- name: ListNodesForAdminKey :many
SELECT nak.id, nak.node_id, nak.admin_key_id, nak.applied_at, nak.is_current, n.name as node_name, n.hardware_id
FROM node_admin_keys nak
JOIN nodes n ON nak.node_id = n.id
WHERE nak.admin_key_id = $1
ORDER BY nak.applied_at DESC
`

type ListNodesForAdminKeyRow struct {
	ID         int64     `json:"id"`
	NodeID     int64     `json:"node_id"`
	AdminKeyID int64     `json:"admin_key_id"`
	AppliedAt  time.Time `json:"applied_at"`
	IsCurrent  bool      `json:"is_current"`
	NodeName   string    `json:"node_name"`
	HardwareID string    `json:"hardware_id"`
}

func (q *Queries) ListNodesForAdminKey(ctx context.Context, adminKeyID int64) ([]ListNodesForAdminKeyRow, error) {
	rows, err := q.db.Query(ctx, listNodesForAdminKey, adminKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNodesForAdminKeyRow
	for rows.Next() {
		var i ListNodesForAdminKeyRow
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.AdminKeyID,
			&i.AppliedAt,
			&i.IsCurrent,
			&i.NodeName,
			&i.HardwareID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAdminKeyNotCurrent = `-- name: MarkAdminKeyNotCurrent :exec
UPDATE node_admin_keys
SET is_current = FALSE
WHERE node_id = $1 AND admin_key_id = $2
`

type MarkAdminKeyNotCurrentParams struct {
	NodeID     int64 `json:"node_id"`
	AdminKeyID int64 `json:"admin_key_id"`
}

func (q *Queries) MarkAdminKeyNotCurrent(ctx context.Context, arg MarkAdminKeyNotCurrentParams) error {
	_, err := q.db.Exec(ctx, markAdminKeyNotCurrent, arg.NodeID, arg.AdminKeyID)
	return err
}
